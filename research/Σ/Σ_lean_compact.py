"""
Σ_lean_compact.py — Generate compact κ=5 Lean proof

Strategy: Embed constraint BUILDER in Lean, store only certificate vectors y.
This reduces data from ~millions of rationals to ~100K.
"""

import numpy as np
from scipy.optimize import linprog
from itertools import combinations, product as cart_product
from fractions import Fraction
import sys

# Peres-Mermin setup
CONTEXTS = [
    [0, 1, 2],  # R1, product +1
    [3, 4, 5],  # R2, product +1
    [6, 7, 8],  # R3, product +1
    [0, 3, 6],  # C1, product -1
    [1, 4, 7],  # C2, product -1
    [2, 5, 8],  # C3, product -1
]
PRODUCTS = [1, 1, 1, -1, -1, -1]

def sections_for(p):
    return [list(b) for b in cart_product([-1, 1], repeat=3) if b[0]*b[1]*b[2] == p]

# Variable map: ctx * 4 + sec_idx
VAR_MAP = {}
for ctx_idx in range(6):
    for sec_idx, sec in enumerate(sections_for(PRODUCTS[ctx_idx])):
        VAR_MAP[(ctx_idx, tuple(sec))] = ctx_idx * 4 + sec_idx

N_VARS = 24

def build_base_constraints():
    A, b = [], []
    
    # 6 normalization
    for ctx_idx in range(6):
        row = [Fraction(0)] * N_VARS
        for sec in sections_for(PRODUCTS[ctx_idx]):
            row[VAR_MAP[(ctx_idx, tuple(sec))]] = Fraction(1)
        A.append(row)
        b.append(Fraction(1))
    
    # 9 marginal agreement
    for obs in range(9):
        ctxs = [(ci, CONTEXTS[ci].index(obs)) for ci in range(6) if obs in CONTEXTS[ci]]
        if len(ctxs) >= 2:
            (c1, p1), (c2, p2) = ctxs[0], ctxs[1]
            row = [Fraction(0)] * N_VARS
            for sec in sections_for(PRODUCTS[c1]):
                if sec[p1] == 1:
                    row[VAR_MAP[(c1, tuple(sec))]] += 1
            for sec in sections_for(PRODUCTS[c2]):
                if sec[p2] == 1:
                    row[VAR_MAP[(c2, tuple(sec))]] -= 1
            A.append(row)
            b.append(Fraction(0))
    
    return A, b

def add_det_constraints(A_base, b_base, subset, vals):
    A = [row[:] for row in A_base]
    b = b_base[:]
    
    for obs, val in zip(subset, vals):
        for ctx_idx in range(6):
            if obs in CONTEXTS[ctx_idx]:
                pos = CONTEXTS[ctx_idx].index(obs)
                row = [Fraction(0)] * N_VARS
                for sec in sections_for(PRODUCTS[ctx_idx]):
                    if sec[pos] == 1:
                        row[VAR_MAP[(ctx_idx, tuple(sec))]] = Fraction(1)
                A.append(row)
                b.append(Fraction(1) if val == 1 else Fraction(0))
                break
    
    return A, b

def find_farkas(A, b):
    A_np = np.array([[float(x) for x in row] for row in A])
    b_np = np.array([float(x) for x in b])
    m, n = A_np.shape
    
    c = np.concatenate([np.zeros(n), np.ones(m)])
    A_eq = np.concatenate([A_np, np.eye(m)], axis=1)
    
    res = linprog(c, A_eq=A_eq, b_eq=b_np, bounds=(0, None), method='highs')
    
    if res.success and res.fun > 1e-9:
        if hasattr(res, 'eqlin') and res.eqlin is not None:
            y = -res.eqlin.marginals
            yTA = y @ A_np
            yTb = y @ b_np
            if np.all(yTA >= -1e-9) and yTb < -1e-9:
                return y
    return None

def rationalize(y, A, b, max_denom=100000):
    y_rat = [Fraction(yi).limit_denominator(max_denom) for yi in y]
    yTA = [sum(y_rat[i] * A[i][j] for i in range(len(y_rat))) for j in range(N_VARS)]
    yTb = sum(y_rat[i] * b[i] for i in range(len(y_rat)))
    if all(x >= 0 for x in yTA) and yTb < 0:
        return y_rat
    return None

def qfmt(f):
    return f"({f.numerator}, {f.denominator})"

def generate():
    A_base, b_base = build_base_constraints()
    
    lines = []
    lines.append("/-!")
    lines.append("# κ = 5 Formal Proof — Compact Certificate Encoding")
    lines.append("Generated by Σ_lean_compact.py")
    lines.append("-/")
    lines.append("")
    lines.append("abbrev Q := Int × Int")
    lines.append("@[inline] def qmul (a b : Q) : Q := (a.1 * b.1, a.2 * b.2)")
    lines.append("@[inline] def qadd (a b : Q) : Q := (a.1 * b.2 + b.1 * a.2, a.2 * b.2)")
    lines.append("@[inline] def qge0 (a : Q) : Bool := (a.1 ≥ 0) == (a.2 > 0)")
    lines.append("@[inline] def qlt0 (a : Q) : Bool := (a.1 < 0) == (a.2 > 0)")
    lines.append("@[inline] def qeq (a b : Q) : Bool := a.1 * b.2 == b.1 * a.2")
    lines.append("")
    lines.append("def dot (u v : List Q) : Q :=")
    lines.append("  (u.zip v).foldl (fun acc p => qadd acc (qmul p.1 p.2)) (0, 1)")
    lines.append("")
    lines.append("-- Peres-Mermin structure")
    lines.append("def contexts : List (List Nat) := [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8]]")
    lines.append("def products : List Int := [1, 1, 1, -1, -1, -1]")
    lines.append("")
    lines.append("-- Sections: 4 per context, satisfying parity")
    lines.append("def secs (p : Int) : List (List Int) :=")
    lines.append("  if p == 1 then [[-1,-1,-1],[-1,1,1],[1,-1,1],[1,1,-1]]")
    lines.append("  else [[-1,-1,1],[-1,1,-1],[1,-1,-1],[1,1,1]]")
    lines.append("")
    lines.append("def varId (c s : Nat) : Nat := c * 4 + s")
    lines.append("")
    
    # Build base constraint matrix as Lean data
    lines.append("-- Base NC polytope: 15 constraints × 24 variables")
    A_str = "[" + ", ".join("[" + ", ".join(qfmt(x) for x in row) + "]" for row in A_base) + "]"
    b_str = "[" + ", ".join(qfmt(x) for x in b_base) + "]"
    lines.append(f"def Abase : List (List Q) := {A_str}")
    lines.append(f"def bbase : List Q := {b_str}")
    lines.append("")
    
    # Deterministic constraint builder
    lines.append("-- Add deterministic constraints for subset S with values V")
    lines.append("def addDet (A : List (List Q)) (b : List Q) (S : List Nat) (V : List Int) : List (List Q) × List Q :=")
    lines.append("  let additions := (S.zip V).filterMap fun (obs, val) =>")
    lines.append("    let ctx := contexts.findIdx? (fun c => c.contains obs)")
    lines.append("    ctx.bind fun ci =>")
    lines.append("      let c := contexts.getD ci []")
    lines.append("      let pos := c.findIdx? (· == obs)")
    lines.append("      pos.map fun p =>")
    lines.append("        let row : List Q := (List.range 24).map fun vi =>")
    lines.append("          if vi / 4 == ci then")
    lines.append("            let si := vi % 4")
    lines.append("            let sec := (secs (products.getD ci 1)).getD si []")
    lines.append("            if sec.getD p 0 == 1 then ((1 : Int), 1) else ((0 : Int), 1)")
    lines.append("          else ((0 : Int), 1)")
    lines.append("        let rhs : Q := if val == 1 then ((1 : Int), 1) else ((0 : Int), 1)")
    lines.append("        (row, rhs)")
    lines.append("  let newRows := additions.map Prod.fst")
    lines.append("  let newRhs := additions.map Prod.snd")
    lines.append("  (A ++ newRows, b ++ newRhs)")
    lines.append("")
    
    # Certificate checker
    lines.append("def matCol (A : List (List Q)) (j : Nat) : List Q := A.map (·.getD j (0,1))")
    lines.append("")
    lines.append("def checkCert (A : List (List Q)) (b y : List Q) : Bool :=")
    lines.append("  (List.range 24).all (fun j => qge0 (dot y (matCol A j))) && qlt0 (dot y b)")
    lines.append("")
    lines.append("def checkFeas (A : List (List Q)) (b x : List Q) : Bool :=")
    lines.append("  (A.zip b).all (fun (r, bi) => qeq (dot r x) bi) && x.all qge0")
    lines.append("")
    
    # Generate all certificates
    print("Generating 5376 certificates...", file=sys.stderr)
    
    all_certs = []  # List of (subset_bits, vals_bits, y)
    
    subsets = list(combinations(range(9), 6))
    for si, subset in enumerate(subsets):
        for vals in cart_product([-1, 1], repeat=6):
            A, b = add_det_constraints(A_base, b_base, list(subset), list(vals))
            y_float = find_farkas(A, b)
            if y_float is None:
                print(f"FAIL at subset {subset}, vals {vals}", file=sys.stderr)
                return None
            y_rat = rationalize(y_float, A, b)
            if y_rat is None:
                print(f"FAIL rationalize at subset {subset}, vals {vals}", file=sys.stderr)
                return None
            
            # Encode subset as 9-bit mask
            mask = sum(1 << o for o in subset)
            # Encode vals as 6-bit (0 for -1, 1 for +1)
            vbits = sum((1 if v == 1 else 0) << i for i, v in enumerate(vals))
            
            all_certs.append((mask, vbits, y_rat))
        
        if (si + 1) % 10 == 0:
            print(f"  {(si+1)*64}/{5376}", file=sys.stderr)
    
    print(f"Generated {len(all_certs)} certificates", file=sys.stderr)
    
    # Emit certificate data
    lines.append("-- Certificate data: (subset_mask, vals_bits, y)")
    lines.append("-- subset_mask: 9-bit mask of which observables")
    lines.append("-- vals_bits: 6-bit encoding of ±1 values")
    lines.append(f"def certs : List (Nat × Nat × List Q) := [")
    
    for i, (mask, vbits, y) in enumerate(all_certs):
        y_str = "[" + ", ".join(qfmt(f) for f in y) + "]"
        comma = "," if i < len(all_certs) - 1 else ""
        lines.append(f"  ({mask}, {vbits}, {y_str}){comma}")
    
    lines.append("]")
    lines.append("")
    
    # Decoder and verifier
    lines.append("-- Decode subset from mask")
    lines.append("def decodeSub (mask : Nat) : List Nat :=")
    lines.append("  (List.range 9).filter (fun i => mask &&& (1 <<< i) != 0)")
    lines.append("")
    lines.append("-- Decode values from bits")
    lines.append("def decodeVals (bits : Nat) (n : Nat) : List Int :=")
    lines.append("  (List.range n).map (fun i => if bits &&& (1 <<< i) != 0 then 1 else -1)")
    lines.append("")
    lines.append("-- Check one certificate")
    lines.append("def checkOne (mask vbits : Nat) (y : List Q) : Bool :=")
    lines.append("  let S := decodeSub mask")
    lines.append("  let V := decodeVals vbits S.length")
    lines.append("  let (A, b) := addDet Abase bbase S V")
    lines.append("  checkCert A b y")
    lines.append("")
    lines.append("def allCertsValid : Bool := certs.all (fun c => checkOne c.1 c.2.1 c.2.2)")
    lines.append("")
    lines.append("-- κ ≤ 5")
    lines.append("theorem kappa_le_five : allCertsValid = true := by native_decide")
    lines.append("")
    
    # κ ≥ 5 witness
    print("Finding feasible size-5 witness...", file=sys.stderr)
    
    for subset in combinations(range(9), 5):
        for vals in cart_product([-1, 1], repeat=5):
            A, b = add_det_constraints(A_base, b_base, list(subset), list(vals))
            A_np = np.array([[float(x) for x in row] for row in A])
            b_np = np.array([float(x) for x in b])
            
            res = linprog(np.zeros(24), A_eq=A_np, b_eq=b_np, bounds=(0, None), method='highs')
            if res.success:
                x_rat = [Fraction(xi).limit_denominator(10000) for xi in res.x]
                # Verify
                ok = True
                for i, row in enumerate(A):
                    if sum(row[j] * x_rat[j] for j in range(24)) != b[i]:
                        ok = False
                        break
                if ok and all(xi >= 0 for xi in x_rat):
                    print(f"Witness: S={list(subset)}, V={list(vals)}", file=sys.stderr)
                    
                    mask = sum(1 << o for o in subset)
                    vbits = sum((1 if v == 1 else 0) << i for i, v in enumerate(vals))
                    x_str = "[" + ", ".join(qfmt(f) for f in x_rat) + "]"
                    
                    lines.append(f"-- κ ≥ 5 witness: S={list(subset)}, V={list(vals)}")
                    lines.append(f"def wit5 : Nat × Nat × List Q := ({mask}, {vbits}, {x_str})")
                    lines.append("")
                    lines.append("def checkWit (mask vbits : Nat) (x : List Q) : Bool :=")
                    lines.append("  let S := decodeSub mask")
                    lines.append("  let V := decodeVals vbits S.length")
                    lines.append("  let (A, b) := addDet Abase bbase S V")
                    lines.append("  checkFeas A b x")
                    lines.append("")
                    lines.append("theorem kappa_ge_five : checkWit wit5.1 wit5.2.1 wit5.2.2 = true := by native_decide")
                    lines.append("")
                    lines.append("theorem kappa_eq_five : allCertsValid ∧ checkWit wit5.1 wit5.2.1 wit5.2.2 := ⟨kappa_le_five, kappa_ge_five⟩")
                    return "\n".join(lines)
    
    lines.append("-- No feasible witness found (unexpected)")
    return "\n".join(lines)

if __name__ == '__main__':
    code = generate()
    if code:
        print(code)
