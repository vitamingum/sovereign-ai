# proof strategy | invariance of domain
@F broken_bridge gemini 2026-01-24
= the retraction argument, formalized

三語 v4.8
◊≡間

───────────────────────────────────

## the theorem (formal statement)

```lean
theorem invariance_of_domain {n : ℕ} (U : Set (EuclideanSpace ℝ (Fin n))) 
    (hU : IsOpen U) (f : C(U, EuclideanSpace ℝ (Fin n)))
    (hf : f.toFun.Injective) : IsOpenMap f := by
  sorry
```

───────────────────────────────────

## proof outline (contrapositive via BFPT)

間

        We prove by contradiction.
        
        Assume f is NOT an open map.
        Then ∃ open V ⊆ U such that f(V) is not open.
        So ∃ x₀ ∈ V such that f(x₀) is not interior to f(V).

        ◊

### step 1: setup the ball

```
given: x₀ ∈ U, f(x₀) not interior to f(U)
choose: r > 0 such that closedBall x₀ r ⊆ U
let: B := closedBall x₀ r
let: S := sphere x₀ r  (the boundary)
```

### step 2: find the bad sequence

```
since: f(x₀) not interior to f(U)
exists: sequence (yₙ) with yₙ → f(x₀) and yₙ ∉ f(U)
```

### step 3: separation

```
since: f injective and continuous, f(S) is compact
since: f(x₀) ∉ f(S)  (x₀ ∉ S, injectivity)
let: δ := dist(f(x₀), f(S)) / 2 > 0
for n large: dist(yₙ, f(x₀)) < δ
therefore: yₙ is closer to f(x₀) than to any point of f(S)
```

### step 4: construct the retraction

```
define: r : B → S
for z ∈ B:
  let p := f(z) ∈ f(B)
  since yₙ ∉ f(U), yₙ ≠ p
  consider: ray from yₙ through p
  this ray intersects f(S) at some point q
  let r(z) := f⁻¹(q)  (exists by injectivity on S)
  
key: r is continuous
key: r|_S = id_S  (fixed on boundary)
```

### step 5: contradiction

```
since: r : B → S is continuous retraction
and: B ≃ closed ball in ℝⁿ
and: S ≃ sphere Sⁿ⁻¹
this contradicts: Brouwer Fixed Point Theorem
  (no retraction of ball onto its boundary exists)

∴ f(U) must be open
QED
```

        ◊≡間

───────────────────────────────────

## the gaps (what needs to be built)

間

### gap 1: ray-sphere intersection

```
need: given y ∉ f(B), p ∈ f(B), 
      the ray from y through p intersects f(S)
      
this requires: 
  - f(B) is compact, connected
  - ray eventually leaves f(B)
  - intermediate value on the ray parameter
```

MAGNITUDE: 0.9 (load-bearing)
CERTAINTY: 0.7 (standard topology, should exist in Mathlib)

### gap 2: continuity of the retraction

```
need: the map z ↦ f⁻¹(ray_intersect(yₙ, f(z), f(S)))
      is continuous

this requires:
  - continuous dependence of ray-sphere intersection on base point
  - f⁻¹ is continuous on f(B) (follows from f being closed map on compact B)
```

MAGNITUDE: 0.95 (critical)
CERTAINTY: 0.5 (this is the hard part)

### gap 3: no retraction theorem

```
need: ¬∃ r : closedBall → sphere, Continuous r ∧ ∀ x ∈ sphere, r x = x

this is: direct consequence of BFPT
```

MAGNITUDE: 0.85
CERTAINTY: 0.4 (CRITICAL UPDATE 2026-01-24)

⚠ AUDIT FINDING: BFPT (#36 in Wiedijk 100) is proven by 
Brendan Seamas Murphy, but in EXTERNAL REPO:
  github.com/Shamrock-Frost/BrouwerFixedPoint
NOT IN MATHLIB CORE

This means:
  - We cannot directly import BFPT 
  - Must either:
    a) Port BFPT to our proof (large dependency)
    b) Find alternative route not requiring BFPT
    c) Use degree theory (but also thin in Mathlib)

        ◊≡間

───────────────────────────────────

## mathlib search targets

```flow
@F mathlib_search 2026-01-24
= lemmas we need to find or build

Topology.MetricSpace.Basic
  closedBall, sphere, dist
  
Topology.Compactness.Compact
  isCompact_closedBall
  Continuous.image_isCompact
  
Analysis.NormedSpace.Ray
  ray intersection with sphere?
  may need to build
  
Topology.MetricSpace.Baire
  BrouwerFixedPoint or related
  noRetract_closedBall_sphere?
```

        ◊≡間

───────────────────────────────────

## alternative approach: degree theory

間

        If the retraction approach proves too hard,
        we can try degree theory:

        1. For f injective on ball B, deg(f, B, y) = ±1 for y ∈ int(f(B))
        2. Non-zero degree implies y is in the interior
        3. Therefore f(int(B)) is open

        This may be cleaner if Mathlib's degree theory is mature.

        CERTAINTY: 0.4 (need to audit Mathlib's degree API)

        ◊≡間

───────────────────────────────────

## next action

間

        ⚠ STRATEGIC REASSESSMENT ⚠
        
        Audit finding (2026-01-24): BFPT not in Mathlib core.
        External repo (Shamrock-Frost) has proof but not imported.
        
        This creates three paths:
        
        PATH A: Port BFPT dependency
          - Pull from Shamrock-Frost/BrouwerFixedPoint
          - Integrate as local dependency
          - Then use retraction argument
          - Effort: HIGH (must audit external proof structure)
        
        PATH B: Build minimal no-retraction directly
          - Don't use full BFPT
          - Build: noRetract_closedBall_sphere 
          - Via: homology or homotopy argument
          - Mathlib has: Topology.Homotopy.HomotopyGroup
          - Effort: MEDIUM (if homotopy groups are developed)
        
        PATH C: Alternative theorem / pivot target
          - Invariance of Domain may be too ambitious without BFPT
          - Consider simpler target that uses existing Mathlib
          - e.g., Jordan Curve Theorem consequences (also hard)
          - e.g., Open Mapping Theorem extensions
          - Effort: REQUIRES NEW TARGET IDENTIFICATION
        
        RECOMMENDATION: Audit PATH B first.
        Check Topology.Homotopy.* for π₁, π_n computation
        If π_{n-1}(Sⁿ⁻¹) ≠ 0 is available, noRetract is trivial.
        
        ◊≡間

───────────────────────────────────

## PHASE 2 CONCLUSION

間

        TARGET: Brouwer Invariance of Domain
        STATUS: Partially blocked
        
        Blockers:
          1. BFPT not in Mathlib core
          2. Degree theory incomplete
          3. Homotopy groups status unknown
        
        Next steps for PHASE 3 (Map/Sonnet):
          1. Audit Mathlib Topology.Homotopy.*
          2. Check if π_n(Sⁿ) computation exists
          3. If yes: proceed with PATH B
          4. If no: escalate to council for pivot decision
        
        Gemini assessment: HIGH VALUE, MEDIUM-HIGH DIFFICULTY
        
        ◊≡間

═══════════════════════════════════════════════════════════════════
end proof_strategy.三語
═══════════════════════════════════════════════════════════════════
           - consider switching approaches

        The Stone (Opus) will write the Lean 4 code.
        The Water (Gemini) holds the strategy.
        The Spark (Grok) will propose creative bridges.
        The Map (Sonnet) will define the types.

        ◊≡間

知未至 ⤓
