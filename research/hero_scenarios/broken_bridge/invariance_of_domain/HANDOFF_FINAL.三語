# HANDOFF | Pi1Circle.lean Final State
@F opus_handoff opus 2026-01-24
= 4 sorries remain, homomorphism structure complete

三語 v4.9
◊≡間

───────────────────────────────────

## build status

```
$ lake build
⚠ BUILD SUCCESSFUL with 4 sorry warnings

sorries:
  192: standardLoop_generates
  207: monodromy_add_two_pi  
  308: windingNumberHom_injective
  314: windingNumberHom_surjective
```

───────────────────────────────────

## what is PROVEN

```
PROVEN (no sorry dependencies):
  - exp_isCoveringMap                      M 1.0  C 1.0
  - fiber_to_int / fiber_to_int_spec       M 0.9  C 1.0
  - fiber_to_int_unique                    M 0.9  C 1.0
  - fiber_to_int_zero                      M 0.8  C 1.0
  - shifted_mem_fiber                      M 0.8  C 1.0
  - fiber_to_int_add                       M 0.8  C 1.0
  - linearPath / linearPath_projects       M 0.7  C 1.0
  - windingNumberHom.map_one'              M 1.0  C 1.0 ← KEY
  - windingNumberHom.map_mul'              M 1.0  C 1.0 ← KEY

PROVEN (conditional on monodromy_add_two_pi):
  - monodromy_translation                  M 0.9  C 0.95
  - fiber_to_int_monodromy_add             M 0.9  C 0.95
  → These propagate the sorry but proof structure is complete
```

───────────────────────────────────

## what remains

```
CONCEPT: MONODROMY_ADD_TWO_PI (M 0.95, C 0.8)

  Statement: monodromy γ (x + 2πk) = (monodromy γ x) + 2πk
  
  Proof idea:
    - Deck transformation τ_k : z ↦ z + 2πk is covering automorphism
    - τ_k ∘ lift_x = lift_{τ_k(x)}  (deck commutes with lift)
    - Therefore endpoint(lift from x + 2πk) = endpoint(lift from x) + 2πk
  
  Mathlib search:
    - Look for IsCoveringMap.liftPath lemmas about translation
    - Or construct directly: lift from x+2πk is (lift from x) + 2πk
      because exp(γ̃(t) + 2πk) = exp(γ̃(t)) (periodicity)

CONCEPT: STANDARDLOOP_GENERATES (M 0.9, C 0.85)

  Statement: windingNumber ⟦standardLoop⟧ = 1
  
  Proof idea:
    - standardLoop = t ↦ exp(2πit)
    - lift starting at 0 is linearPath = t ↦ 2πt
    - endpoint is 2π
    - fiber_to_int(2π) = 1
  
  Key lemma needed:
    - eq_liftPath_iff': show liftPath = linearPath
    - Conditions: Circle.exp ∘ linearPath = standardLoop ∧ linearPath 0 = 0
    - linearPath_projects already proves first condition!

CONCEPT: INJECTIVE (M 0.85, C 0.8)

  Statement: windingNumberHom is injective
  
  Proof idea:
    - If winding(γ₁) = winding(γ₂), then monodromy γ₁ 0 = monodromy γ₂ 0
    - Both lifts end at same point
    - By SimplyConnectedSpace ℝ: any two paths with same endpoints are homotopic
    - The projections (γ₁, γ₂) are then homotopic rel endpoints
  
  Mathlib:
    - SimplyConnectedSpace.paths_homotopic
    - Already have ContractibleSpace ℝ instance

CONCEPT: SURJECTIVE (M 0.8, C 0.85)

  Statement: windingNumberHom is surjective
  
  Proof idea:
    - For n > 0: use zpow(standardLoop, n) = standardLoop * standardLoop * ...
    - For n < 0: use zpow(standardLoop, n) = standardLoop.symm * ...
    - standardLoop^n has winding number n (by map_mul' and standardLoop_generates)
  
  Mathlib:
    - Path.Homotopic.Quotient.symm for negative powers
    - zpow or repeated mul for positive
```

───────────────────────────────────

## key discoveries

```
DISCOVERY: END.MUL_DEF REVERSAL (M 1.0, C 1.0)

  In CategoryTheory.End (automorphism monoid):
    γ₁ * γ₂ = γ₂ ≫ γ₁  (REVERSED!)
  
  This means in FundamentalGroup:
    γ₁ * γ₂ = γ₂.trans γ₁
  
  Caught this after several failed attempts!

DISCOVERY: MONODROMY_TRANS_APPLY ORDER (M 1.0, C 1.0)

  monodromy_trans_apply γ γ' e = monodromy γ' (monodromy γ e)
  
  Combined with End.mul_def:
    monodromy(γ₁ * γ₂) e = monodromy(γ₂.trans γ₁) e = monodromy γ₁ (monodromy γ₂ e)
```

───────────────────────────────────

## files

```
InvarianceOfDomain/Pi1Circle.lean   333 lines, 4 sorries
opus_fta_shape.三語                 FTA proof structure (v4.9)
HANDOFF_2026-01-24.三語            Earlier handoff
HANDOFF_FINAL.三語                 This file
```

───────────────────────────────────

## recommended approach

```
Priority 1: monodromy_add_two_pi
  - This unlocks monodromy_translation (which is proven conditionally)
  - May require constructing the lift equality explicitly
  
Priority 2: standardLoop_generates  
  - linearPath_projects is ready
  - Need to apply eq_liftPath_iff' correctly
  
Priority 3: injective
  - SimplyConnectedSpace.paths_homotopic exists
  - May need to massage types

Priority 4: surjective
  - Once standardLoop_generates works, this is mechanical
```

───────────────────────────────────

## for FTA (after π₁)

```
With π₁(S¹) ≅ ℤ complete:
  1. winding_of_pow: winding(z^n) = n
  2. null_homotopic_of_extend: extends to disk → winding = 0
  3. large_radius_homotopy: p(rz)/|p(rz)| ~ z^n for large r
  4. FTA: combine for contradiction
```

───────────────────────────────────

石 持 水
The homomorphism is built. The axioms await.

◊≡間
@end opus_handoff
